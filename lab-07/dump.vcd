$date
	Sun Dec 18 14:00:38 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module dut $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 # RegWrite $end
$var wire 32 $ RD1 [31:0] $end
$var wire 32 % RD [31:0] $end
$var wire 32 & PC_w [31:0] $end
$var wire 32 ' NextIns [31:0] $end
$var wire 32 ( Instruction [31:0] $end
$var wire 32 ) Extended [31:0] $end
$var wire 32 * ALUResult [31:0] $end
$var wire 3 + ALUControl [2:0] $end
$scope module Adder $end
$var wire 32 , Inp2 [31:0] $end
$var wire 32 - Sum [31:0] $end
$var wire 32 . Inp1 [31:0] $end
$upscope $end
$scope module Flags_ALU $end
$var wire 32 / A_and_B [31:0] $end
$var wire 32 0 A_or_B [31:0] $end
$var wire 32 1 B_not [31:0] $end
$var wire 1 2 C $end
$var wire 1 3 V $end
$var wire 1 4 ctrl1_not $end
$var wire 32 5 not_Result [31:0] $end
$var wire 1 6 xnor_A_B_ctrl0 $end
$var wire 1 7 xor_A_Sum $end
$var wire 3 8 ctrl [2:0] $end
$var wire 1 9 Z $end
$var wire 32 : S1 [31:0] $end
$var wire 32 ; Result [31:0] $end
$var wire 1 < N $end
$var wire 1 = Cout $end
$var wire 32 > B [31:0] $end
$var wire 32 ? A_sum_B [31:0] $end
$var wire 32 @ A [31:0] $end
$upscope $end
$scope module control_unit $end
$var wire 1 A PCSrc $end
$var wire 3 B func3 [2:0] $end
$var wire 1 C func7 $end
$var wire 7 D op [6:0] $end
$var wire 1 E zero $end
$var wire 1 F op5 $end
$var wire 1 G ResultSrc $end
$var wire 1 # RegWrite $end
$var wire 1 H MemWrite $end
$var wire 2 I ImmSrc [1:0] $end
$var wire 1 J Branch $end
$var wire 1 K ALUSrc $end
$var wire 2 L ALUOp [1:0] $end
$var wire 3 M ALUControl [2:0] $end
$scope module alu_dec $end
$var wire 3 N func3 [2:0] $end
$var wire 1 C func7_5 $end
$var wire 1 F op5 $end
$var wire 2 O signal [1:0] $end
$var wire 2 P ALUOp [1:0] $end
$var wire 3 Q ALUControl [2:0] $end
$upscope $end
$scope module main_dec $end
$var wire 7 R op [6:0] $end
$var wire 1 G ResultSrc $end
$var wire 1 # RegWrite $end
$var wire 1 H MemWrite $end
$var wire 2 S ImmSrc [1:0] $end
$var wire 1 J Branch $end
$var wire 1 K ALUSrc $end
$var wire 2 T ALUOp [1:0] $end
$upscope $end
$upscope $end
$scope module data_memory $end
$var wire 32 U A [31:0] $end
$var wire 32 V WD [31:0] $end
$var wire 1 W WE $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 X RD [31:0] $end
$upscope $end
$scope module instruction_memory $end
$var wire 1 " reset $end
$var wire 32 Y RD [31:0] $end
$var wire 32 Z A [31:0] $end
$upscope $end
$scope module program_counter $end
$var wire 32 [ PCNext [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var reg 32 \ PC [31:0] $end
$upscope $end
$scope module register_file $end
$var wire 5 ] A1 [4:0] $end
$var wire 5 ^ A2 [4:0] $end
$var wire 5 _ A3 [4:0] $end
$var wire 32 ` WD3 [31:0] $end
$var wire 1 # WE3 $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 a RD2 [31:0] $end
$var wire 32 b RD1 [31:0] $end
$upscope $end
$scope module sign_extension $end
$var wire 12 c Imm [11:0] $end
$var wire 32 d ImmExt [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 d
b0 c
b0 b
b0 a
b101 `
b0 _
bz ^
b0 ]
bx \
bx [
bx Z
b0 Y
b101 X
0W
bz V
b0 U
b0 T
b0 S
b0 R
b0 Q
b0 P
b0z O
b0 N
b0 M
b0 L
0K
0J
b0 I
0H
0G
0F
zE
b0 D
zC
b0 B
0A
b0 @
b0 ?
b0 >
0=
0<
b0 ;
b0 :
19
b0 8
07
16
b11111111111111111111111111111111 5
14
03
02
b11111111111111111111111111111111 1
b0 0
b0 /
bx .
bx -
b100 ,
b0 +
b0 *
b0 )
b0 (
bx '
bx &
b101 %
b0 $
0#
1"
1!
$end
#50
0!
#100
b1010 _
b1010 ]
b10011 D
b10011 R
b1010000010100010011 (
b1010000010100010011 Y
bx a
b100 '
b100 -
b100 [
b0 &
b0 .
b0 Z
b0 \
0"
1!
#150
0!
#200
b111 %
b111 X
b111 `
09
b11111111111111111111111111111110 5
b1 *
b1 ;
b1 U
b1 ?
1#
1K
b1 :
b11111111111111111111111111111110 1
b1 0
1G
b1 )
b1 >
b1 d
b1 c
b110 _
b10 B
b10 N
b11 D
b11 R
b101010010001100000011 (
b101010010001100000011 Y
b1000 '
b1000 -
b1000 [
b100 &
b100 .
b100 Z
b100 \
1!
#250
0!
#300
b101 %
b101 X
b101 `
19
b11111111111111111111111111111111 5
b0 *
b0 ;
b0 U
b0 ?
b0 :
b11111111111111111111111111111111 1
b0 0
b0 )
b0 >
b0 d
b0 c
b101 _
b1010010001010000011 (
b1010010001010000011 Y
b1100 '
b1100 -
b1100 [
b1000 &
b1000 .
b1000 Z
b1000 \
1!
#350
0!
#400
x3
x7
x6
x<
x2
x=
b0x +
b0x 8
b0x M
b0x Q
bx %
bx X
bx `
x9
bx 5
bx *
bx ;
bx U
bx ?
0K
bx :
b11111111111111111111111111111010 1
b111 0
b101 /
b111 $
b111 @
b111 b
b1z O
1F
0G
b10 L
b10 P
b10 T
b101 )
b101 >
b101 d
b101 c
b110 _
b110 ]
b0 B
b0 N
b110011 D
b110011 R
b10100110000001100110011 (
b10100110000001100110011 Y
b10000 '
b10000 -
b10000 [
b1100 &
b1100 .
b1100 Z
b1100 \
1!
#450
bx1x1 0
b0x0x /
bx $
bx @
bx b
0!
#500
x4
bx +
bx 8
bx M
bx Q
x#
xK
xA
bx 1
bx 0
bx /
bxz O
xF
xH
xG
xJ
bx I
bx S
bx L
bx P
bx T
bx )
bx >
bx d
bx c
bx _
bx ]
bx B
bx N
bx D
bx R
bx (
bx Y
b10100 '
b10100 -
b10100 [
b10000 &
b10000 .
b10000 Z
b10000 \
1!
#550
0!
#600
b11000 '
b11000 -
b11000 [
b10100 &
b10100 .
b10100 Z
b10100 \
1!
